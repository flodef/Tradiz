'use client';

import { encodeURL, findReference, FindReferenceError, ValidateTransferError } from '@solana/pay';
import { Connection, Keypair, PublicKey, TransactionSignature } from '@solana/web3.js';
import BigNumber from 'bignumber.js';
import { FC, ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useConfig } from '../hooks/useConfig';
import { Crypto, CryptoContext, PaymentStatus } from '../hooks/useCrypto';
import { useData } from '../hooks/useData';
import { useWindowParam } from '../hooks/useWindowParam';
import { ENDPOINT, SPL_TOKEN, TRANSACTION_TIME_OUT } from '../utils/constants';
import { Confirmations } from '../utils/types';
import { validateTransfer } from '../utils/validateTransfer';

export interface CryptoProviderProps {
    children: ReactNode;
}

export const CryptoProvider: FC<CryptoProviderProps> = ({ children }) => {
    const { total } = useData();
    const { paymentMethods, parameters, currencies, currencyIndex } = useConfig();
    const { isOnline } = useWindowParam();

    const requiredConfirmations = 1;

    const [crypto, setCrypto] = useState<Crypto>(Crypto.Solana);
    const splToken = useMemo(() => SPL_TOKEN, []);
    const recipient = useMemo(() => {
        switch (crypto) {
            case Crypto.Solana:
                return new PublicKey(paymentMethods.find((item) => item.type === Crypto.Solana)?.id ?? 0);
            case Crypto.June:
                return new PublicKey(paymentMethods.find((item) => item.type === Crypto.June)?.id?.split(':')[0] ?? 0);
            default:
                return new PublicKey(0);
        }
    }, [paymentMethods, crypto]);

    const amount = useMemo(() => BigNumber(total), [total]);
    const connection = useRef(new Connection(ENDPOINT, 'confirmed'));
    const [memo, setMemo] = useState<string>();
    const [reference, setReference] = useState<PublicKey>();
    const [signature, setSignature] = useState<TransactionSignature>();
    const [paymentStatus, setPaymentStatus] = useState(PaymentStatus.New);
    const [error, setError] = useState<Error>();
    const [refresh, setRefresh] = useState(false);
    const refPaymentStatus = useRef(paymentStatus);

    useEffect(() => {
        BigNumber.config({ DECIMAL_PLACES: currencies[currencyIndex].decimals ?? 0 });
    }, [currencies, currencyIndex]);

    useEffect(() => {
        if (error) {
            setPaymentStatus(PaymentStatus.Error);
        }
    }, [error]);

    useEffect(() => {
        refPaymentStatus.current = paymentStatus;
    }, [paymentStatus]);

    const url = useMemo(() => {
        switch (crypto) {
            case Crypto.Solana:
                return encodeURL({
                    recipient,
                    amount,
                    splToken,
                    reference,
                    label: parameters.shop.name,
                    message: parameters.thanksMessage,
                    memo,
                });
            case Crypto.June:
                const url = new URL('june://' + recipient.toBase58());

                if (amount) {
                    url.searchParams.append('amount', amount.toString());
                }

                return url;
            default:
                return '';
        }
    }, [parameters.shop.name, memo, parameters.thanksMessage, recipient, splToken, reference, amount, crypto]);

    const init = useCallback(() => {
        setPaymentStatus(PaymentStatus.New);
        setReference(undefined);
        setError(undefined);
    }, []);

    const generate = useCallback(
        (crypto: Crypto) => {
            setCrypto(crypto);
            setPaymentStatus(PaymentStatus.Pending);
            setReference(crypto === Crypto.Solana ? Keypair.generate().publicKey : undefined);
            setMemo(undefined);
            setSignature(undefined);
            setError(undefined);
            setRefresh(true);
        },
        [setError]
    );

    const retry = useCallback(() => {
        if (refPaymentStatus.current === PaymentStatus.Error) {
            setPaymentStatus(PaymentStatus.Pending);
            setSignature(undefined);
            setError(undefined);
            setRefresh(true);
        }
        watchDog.current = 0;
    }, [setError]);

    // When the status is pending, poll for the transaction using the reference key
    const watchDog = useRef(0);
    useEffect(() => {
        if (!(paymentStatus === PaymentStatus.Pending && !signature && refresh && isOnline)) return;
        let changed = false;

        const interval = setInterval(async () => {
            try {
                if (crypto === Crypto.Solana && reference) {
                    const signature = await findReference(connection.current as any, reference);

                    if (!changed) {
                        watchDog.current = 0;
                        clearInterval(interval);
                        setSignature(signature.signature);
                        setPaymentStatus(PaymentStatus.Confirmed);
                    }
                } else if (crypto === Crypto.June) {
                    const result = await fetch(`https://g1.duniter.org/tx/history/${recipient.toBase58()}`);
                    const data = await result.json();
                    const receiving =
                        Number(
                            data.history.pending
                                .at(data.history.pending.length - 1)
                                ?.outputs.at(0)
                                ?.split(':')[0]
                        ) / 100;

                    if (receiving !== amount.toNumber()) throw new FindReferenceError();

                    if (!changed) {
                        watchDog.current = 0;
                        clearInterval(interval);
                        setPaymentStatus(PaymentStatus.Finalized);
                    }
                }
            } catch (error: any) {
                const isTimeOut = watchDog.current++ > TRANSACTION_TIME_OUT * 4;

                // If status is no longer correct or the watch dog has expired, stop polling
                if (paymentStatus !== PaymentStatus.Pending || isTimeOut) {
                    setRefresh(false);
                    watchDog.current = 0;
                    clearInterval(interval);
                    if (isTimeOut) setError(new Error('Transaction timed out'));
                }

                // If the RPC node doesn't have the transaction signature yet, try again
                if (!(error instanceof FindReferenceError)) {
                    setError(error);
                }
            }
        }, 250);

        return () => {
            changed = true;
            watchDog.current = 0;
            clearInterval(interval);
        };
    }, [paymentStatus, reference, signature, connection, setError, refresh, isOnline, crypto, recipient, amount]);

    // When the status is confirmed, validate the transaction against the provided params
    useEffect(() => {
        if (!(paymentStatus === PaymentStatus.Confirmed && signature && amount)) return;
        let changed = false;

        const run = async () => {
            try {
                await validateTransfer(
                    connection.current,
                    signature,
                    {
                        recipient,
                        amount,
                        splToken,
                        reference,
                    },
                    { maxSupportedTransactionVersion: 0 }
                );
                if (!changed) {
                    setPaymentStatus(PaymentStatus.Valid);
                }
            } catch (error: any) {
                // If status is no longer correct, stop polling
                if (paymentStatus !== PaymentStatus.Confirmed) return;

                // If the RPC node doesn't have the transaction yet, try again
                if (
                    error instanceof ValidateTransferError &&
                    (error.message === 'not found' || error.message === 'missing meta')
                ) {
                    console.warn(error);
                    timeout = setTimeout(run, 250);
                    return;
                }

                setError(error);
            }
        };
        let timeout = setTimeout(run, 0);

        return () => {
            changed = true;
            clearTimeout(timeout);
        };
    }, [paymentStatus, signature, amount, connection, splToken, url, reference, setError, recipient]);

    // When the status is valid, poll for confirmations until the transaction is finalized
    useEffect(() => {
        if (!(paymentStatus === PaymentStatus.Valid && signature)) return;
        let changed = false;

        const interval = setInterval(async () => {
            try {
                const response = await connection.current.getSignatureStatus(signature);
                const status = response.value;
                if (!status) return;
                if (status.err) throw status.err;

                if (!changed) {
                    const confirmations = (status.confirmations || 0) as Confirmations;

                    if (confirmations >= requiredConfirmations || status.confirmationStatus === 'finalized') {
                        clearInterval(interval);
                        setPaymentStatus(PaymentStatus.Finalized);
                    }
                }
            } catch (error: any) {
                setError(error);
            }
        }, 250);

        return () => {
            changed = true;
            clearInterval(interval);
        };
    }, [paymentStatus, signature, connection, requiredConfirmations, setError]);

    const errorText = useMemo(() => {
        const errorCode = error?.message.split(':')[0].trim();
        switch (errorCode) {
            case '401':
                return 'Probl√®me de connection au serveur de paiement !';
        }

        switch (error?.message) {
            case 'WalletNotConnectedError':
                return 'Porte-monnaie non connect√© !';
            case 'WalletSignTransactionError':
                return 'Vous avez refus√© la transaction !';
            case 'WalletSendTransactionError':
                return 'Vous avez trop tard√© √† approuver la transaction !';
            case 'TokenAccountNotFoundError':
                return 'Ce commer√ßant doit ajouter la monnaie "{currency}" √† son porte-monnaie !';
            case 'insufficient SOL funds to pay for transaction fee':
                return 'Vous manquez de SOL pour payer les frais de transaction !';
            case 'sender is also recipient':
                return 'Vous √™tes en m√™me temps payeur et pay√©';
            case 'sender not found':
                return 'La monnaie "{currency}" dans votre porte-monnaie est introuvable !';
            case 'sender owner invalid':
                return 'Votre porte-monnaie est invalide !';
            case 'sender executable':
                return 'Votre porte-monnaie est un ex√©cutable / programme !';
            case 'recipient not found':
                return 'La monnaie "{currency}" dans le porte-monnaie de ce commer√ßant est introuvable !';
            case 'recipient owner invalid':
                return 'Le porte-monnaie de ce commer√ßant est invalide !';
            case 'recipient executable':
                return 'Le porte-monnaie de ce commer√ßant est un ex√©cutable / programme !';
            case 'amount decimals invalid':
                return 'Le nombre de d√©cimales du montant est invalide !';
            case 'mint not initialized':
                return 'La monnaie "{currency}" a besoin d\'√™tre initialis√© !';
            case 'sender not initialized':
                return "Votre porte-monnaie a besoin d'√™tre initialis√© !";
            case 'sender frozen':
                return 'Votre porte-monnaie est gel√©; probablement d√ª √† une fraude !';
            case 'recipient not initialized':
                return "Le porte-monnaie de ce commer√ßant a besoin d'√™tre initialis√© !";
            case 'recipient frozen':
                return 'Le porte-monnaie de ce commer√ßant est gel√©; probablement d√ª √† une fraude !';
            case 'insufficient funds':
                return 'Le montant est sup√©rieur √† vos fonds !';
            case 'Failed to fetch':
                return '√âchec de r√©cup√©ration des donn√©es';
            case 'Transaction timed out':
                return 'La transaction a expir√©';
            case 'Message failed to sign':
                return '√âchec de signature du message';
            case 'Airdrop available only on Devnet':
                return "L'airdrop n'est disponible que sur le Devnet";
            case 'FetchDataError':
                return "Avez-vous essay√© de lancer avec HTTPS (USE_HTTP=false) et sans proxy local (voir les param√®tres d'environnement, .env.local) ?";
            case 'GoogleAuthenticatorError':
                return "Avez-vous essay√© de lancer avec GOOGLE_SPREADSHEET_ID / GOOGLE_API_KEY avec les valeurs par d√©faut (voir les param√®tres d'environnement, .env.local) ?";
            case 'RPCError':
                return 'Le serveur de connexion a renvoy√© une erreur';
            case 'CreateTransferError':
                return 'Erreur de transfert !';
            case 'NetworkBusyError':
                return 'Le r√©seau est momentan√©ment satur√©, merci de r√©essayer !';
            case 'InternalError':
                return 'Erreur interne au r√©seau, merci de r√©essayer !';
            case 'UnknownError':
                return 'Erreur inconnue : {error}';
            default:
                return '';
        }
    }, [error]);

    return (
        <CryptoContext.Provider
            value={{
                crypto,
                paymentStatus,
                refPaymentStatus,
                url,
                init,
                generate,
                retry,
                error,
                errorText,
            }}
        >
            {children}
        </CryptoContext.Provider>
    );
};
